/*  Author: Ahmad Saleh
    <gen> tag means this lines will generated by our custom generator
*/

#include "HLS/hls.h"
#include "HLS/stdio.h"
#include "HLS/hls.h"
#include "HLS/hls_float.h"
#include <stdlib.h>



// SUPPORTED AGGREGATIN FUNCTIONS: COUNT, AVERAGE, MIN, MAX
#define BUILDIN_AGGREGATION_FUNCTIONS_NUMBER_OF_SUPPORTED 5
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_COUNT 0
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG   1
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_MIN   2
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_MAX   3
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_SUM   4

#define BUILDIN_NUMBER_OF_TESTS 100
#define BUILDIN_ORDER_OF_TESTS  500


//<gen>
#define TUPLE_DATA_SIZE             4
#define WINDOWING_k                 4
#define AGGREGATION_FUNCTION_CODE   1
#define AGGREGATION_FIELD_CODE      0
//</gen>


struct Tuple {
    bool valid = false;
    int data[TUPLE_DATA_SIZE] = {0};
    bool aggregation_ready = false;
    float aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_NUMBER_OF_SUPPORTED] = {0.0};
};


//<gen>
ihc::stream_in<Tuple> s_in;
ihc::stream_out<Tuple> s_out;
ihc::stream<Tuple> s0;
//</gen>


template <auto &stream_in_tuple, auto &stream_out_tuple> void projection() {

        
    auto tuple = stream_in_tuple.read();

    if (!tuple.valid){
        stream_out_tuple.write(tuple);
        return;
    }


    //<gen>
    int left_hand_cond = (tuple.data[0] * tuple.data[1]);
    int right_hand_cond = 20000;
    bool projection_result = left_hand_cond < right_hand_cond;
    // </gen>

    tuple.valid = projection_result;
    stream_out_tuple.write(tuple);

    return;
}

Tuple aggregation (
                        Tuple in_tuple,
                        int function_code,
                        int field_code,
                        bool eos
){

    static float count=0.0, avg=0.0, min=0.0, max=0.0, sum=0.0;

    if (in_tuple.valid) {
        if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_COUNT){
            count = count + 1;
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG){
            sum = sum + in_tuple.data[field_code];
            count = count + 1;
            avg = sum / count;
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_MAX){
            count = count + 1;
            if (in_tuple.data[field_code] > max){
                max = in_tuple.data[field_code];
            }
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_MIN){
            count = count + 1;
            if (in_tuple.data[field_code] < min){
                min = in_tuple.data[field_code];
            }
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_SUM){
            count = count + 1;
            sum = sum + in_tuple.data[field_code];
        }
    }

    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_COUNT] = count;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG] = avg;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_MAX] = max;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_MIN] = min;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_SUM] = sum;

    if (eos) {
        count = 0;
        avg = 0;
        min = FLT_MAX;
        max = FLT_MIN;
        sum = 0;
        in_tuple.aggregation_ready = true;
    }

    return in_tuple;
}

template <auto &stream_in_tuple, auto &stream_out_tuple> void windowing () {

    static int i = 1;
    auto tuple = stream_in_tuple.read();
    if (!tuple.valid){
        stream_out_tuple.write(tuple);
        return;
    }

    ihc::launch<aggregation>(tuple, AGGREGATION_FUNCTION_CODE, AGGREGATION_FIELD_CODE, i%WINDOWING_k == 0);
    tuple = ihc::collect<aggregation>();

    stream_out_tuple.write(tuple);
    i++;

    return;
}

// component void groupBy (){

// } 

component void streamer (){

    
    //<gen>
    ihc::launch<projection<s_in, s0>>();
    ihc::launch<windowing<s0, s_out>>();
    ihc::collect<projection<s_in, s0>>();
    ihc::collect<windowing<s0, s_out>>();
    //</gen>

}

int main() {

    Tuple tuples[BUILDIN_NUMBER_OF_TESTS];
    Tuple results[BUILDIN_NUMBER_OF_TESTS];

    for (int i = 0; i < BUILDIN_NUMBER_OF_TESTS; i++) {

        tuples[i].valid = true;
        tuples[i].data[0] = (rand() % BUILDIN_ORDER_OF_TESTS);       //price
        tuples[i].data[1] = (rand() % BUILDIN_ORDER_OF_TESTS);       //volume
        tuples[i].data[2] = (rand() % BUILDIN_ORDER_OF_TESTS);       //code
        tuples[i].data[3] = (rand() % BUILDIN_ORDER_OF_TESTS);       //stock

        s_in.write(tuples[i]);

        streamer();

        results[i] = s_out.read();
    }
    

    for (int i = 0; i < BUILDIN_NUMBER_OF_TESTS; i++) {
        

        if (results[i].valid) {
            printf("accepted: price:%d, volume:%d, code:%d, stock:%d, count:%f, avg:%f, min:%f, max:%f, sum:%f, readyag:%d \n",
             results[i].data[0], results[i].data[1], results[i].data[2], results[i].data[3],
             results[i].aggregation_results[0], results[i].aggregation_results[1], 
             results[i].aggregation_results[2], results[i].aggregation_results[3],
             results[i].aggregation_results[4], results[i].aggregation_ready);
        }     
        else {
            printf("rejected: price:%d, volume:%d, code:%d, stock:%d, count:%f, avg:%f, min:%f, max:%f, sum:%f, readyag:%d \n",
             results[i].data[0], results[i].data[1], results[i].data[2], results[i].data[3],
             results[i].aggregation_results[0], results[i].aggregation_results[1], 
             results[i].aggregation_results[2], results[i].aggregation_results[3],
             results[i].aggregation_results[4], results[i].aggregation_ready);
        }
    }

    return 0;

}
