/*  Author: Ahmad Saleh
    <gen> tag means this lines will generated by our custom generator
*/

#include "HLS/hls.h"
#include "HLS/stdio.h"
#include "HLS/hls.h"
#include "HLS/hls_float.h"
#include <stdlib.h>



// SUPPORTED AGGREGATIN FUNCTIONS: COUNT, AVERAGE, MIN, MAX
#define BUILDIN_AGGREGATION_FUNCTIONS_NUMBER_OF_SUPPORTED 5
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_COUNT 0
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG   1
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_MIN   2
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_MAX   3
#define BUILDIN_AGGREGATION_FUNCTIONS_CODE_SUM   4

#define BUILDIN_NUMBER_OF_TESTS 100
#define BUILDIN_ORDER_OF_TESTS  500


//<gen>
#define TUPLE_DATA_SIZE             4
#define WINDOWING_k                 4

//#define AGGREGATION_FUNCTION_CODE   1
//#define AGGREGATION_FIELD_CODE      0

#define PROJECTION_CODE_1           1
//</gen>


struct Tuple {
    bool valid = false;
    int data[TUPLE_DATA_SIZE] = {0};
    bool aggregation_ready[BUILDIN_AGGREGATION_FUNCTIONS_NUMBER_OF_SUPPORTED] = {0};
    float aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_NUMBER_OF_SUPPORTED] = {0.0};
};


//<gen>
ihc::stream<Tuple> s0, s1, s2;
//</gen>


template <auto &stream_in_tuple, auto &stream_out_tuple> void projection(int code) {

        
    auto tuple = stream_in_tuple.read();

    if (!tuple.valid){
        stream_out_tuple.write(tuple);
        return;
    }


    int left_hand_cond, right_hand_cond;
    bool projection_result = true;

    //<gen>
    if(code == PROJECTION_CODE_1) {
        left_hand_cond = (tuple.data[0] * tuple.data[1]);
        right_hand_cond = 20000;
        projection_result = projection_result & (left_hand_cond < right_hand_cond);
    }    
    // </gen>

    tuple.valid = tuple.valid & projection_result;
    stream_out_tuple.write(tuple);

    return;
}

Tuple aggregation (
                        Tuple in_tuple,
                        int function_code,
                        int field_code,
                        bool eos
){

    static float count=0.0, avg=0.0, min=0.0, max=0.0, sum=0.0;

    if (in_tuple.valid) {
        if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_COUNT){
            count = count + 1;
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG){
            sum = sum + in_tuple.data[field_code];
            count = count + 1;
            avg = sum / count;
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_MAX){
            count = count + 1;
            if (in_tuple.data[field_code] > max){
                max = in_tuple.data[field_code];
            }
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_MIN){
            count = count + 1;
            if (in_tuple.data[field_code] < min){
                min = in_tuple.data[field_code];
            }
        }
        else if (function_code == BUILDIN_AGGREGATION_FUNCTIONS_CODE_SUM){
            count = count + 1;
            sum = sum + in_tuple.data[field_code];
        }
    }

    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_COUNT] = count;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG] = avg;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_MAX] = max;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_MIN] = min;
    in_tuple.aggregation_results[BUILDIN_AGGREGATION_FUNCTIONS_CODE_SUM] = sum;

    if (eos) {
        count = 0;
        avg = 0;
        min = FLT_MAX;
        max = FLT_MIN;
        sum = 0;
        in_tuple.aggregation_ready[function_code] = true;
    }

    return in_tuple;
}

template <auto &stream_in_tuple, auto &stream_out_tuple> void windowing (int aggr_function_code, int aggr_field_code) {

    static int i = 1;
    auto tuple = stream_in_tuple.read();
    if (!tuple.valid){
        stream_out_tuple.write(tuple);
        return;
    }

    ihc::launch<aggregation>(tuple, aggr_function_code, aggr_field_code, i%WINDOWING_k == 0);
    tuple = ihc::collect<aggregation>();

    stream_out_tuple.write(tuple);
    i++;

    return;
}

// component void groupBy (){

// } 

hls_avalon_agent_component
component Tuple streamer (hls_avalon_agent_register_argument Tuple tuple){
    
    //<gen>
    s0.write(tuple);
    ihc::launch<projection<s0, s1>>(PROJECTION_CODE_1);
    ihc::launch<windowing<s1, s2>>(BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG, 0);
    ihc::collect<projection<s0, s1>>();
    ihc::collect<windowing<s1, s2>>();
    tuple = s2.read();
    //</gen>

    return tuple;
}

int main() {

    Tuple tuples[BUILDIN_NUMBER_OF_TESTS];
    Tuple results[BUILDIN_NUMBER_OF_TESTS];

    for (int i = 0; i < BUILDIN_NUMBER_OF_TESTS; i++) {

        tuples[i].valid = true;
        tuples[i].data[0] = (rand() % BUILDIN_ORDER_OF_TESTS);       //price
        tuples[i].data[1] = (rand() % BUILDIN_ORDER_OF_TESTS);       //volume
        tuples[i].data[2] = (rand() % BUILDIN_ORDER_OF_TESTS);       //code
        tuples[i].data[3] = (rand() % BUILDIN_ORDER_OF_TESTS);       //stock

        results[i] = streamer(tuples[i]);
        

        if (results[i].valid) {
            printf("accepted: price:%d, volume:%d, code:%d, stock:%d, count:%f, avg:%f, min:%f, max:%f, sum:%f, readyag:%d \n",
             results[i].data[0], results[i].data[1], results[i].data[2], results[i].data[3],
             results[i].aggregation_results[0], results[i].aggregation_results[1], 
             results[i].aggregation_results[2], results[i].aggregation_results[3],
             results[i].aggregation_results[4], results[i].aggregation_ready[BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG]);
        }     
        else {
            printf("rejected: price:%d, volume:%d, code:%d, stock:%d, count:%f, avg:%f, min:%f, max:%f, sum:%f, readyag:%d \n",
             results[i].data[0], results[i].data[1], results[i].data[2], results[i].data[3],
             results[i].aggregation_results[0], results[i].aggregation_results[1], 
             results[i].aggregation_results[2], results[i].aggregation_results[3],
             results[i].aggregation_results[4], results[i].aggregation_ready[BUILDIN_AGGREGATION_FUNCTIONS_CODE_AVG]);
        }
    }
    

    return 0;

}
